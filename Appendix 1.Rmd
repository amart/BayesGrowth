---
title: 'Appendix 1: BayesGrowth example'
output: 
  word_document:
    reference_docx: ~/word-styles-reference-1.docx
---


```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```
# Estimate growth using MCMC


`BayesGrowth` combines length-at-age modelling  with MCMC implemented using JAGS and the [rjags](https://cran.r-project.org/web/packages/rjags/index.html) package. Growth modelling using models such as the von Bertalanffy growth function involves three parameters: $L_{\infty}$, $k$ and either $L_{0}$ or $t_{0}$. Two of these parameters: $L_{0}$ and $L_{\infty}$ have direct biological meaning as the length-at-birth and maximum length, respectively. This package provides the tools to run an MCMC model with these two parameters treated as size-at-birth and maximum length using a JAGS model. This MCMC model is pre-specified and built into wrapper functions.

The user can therefore run an MCMC growth model using knowledge of species length-at-birth and maximum size as priors.

## Installation
This package provides a series of wrapper functions to the `rjags` package which will run JAGS ("Just Another Gibbs Sampler") MCMC models. Therefore, __JAGS must be installed before this package is installed__. To install JAGS, visit:
https://sourceforge.net/projects/mcmc-jags/files/

You can install the released version of `BayesGrowth` from [Github](https://github.com/jonathansmart/BayesGrowth) with:

``` {r, eval = FALSE}
devtools::install_github("jonathansmart/BayesGrowth")
```

## Usage

The main `BayesGrowth` function is `Estimate_MCMC_Growth()` which is the wrapper function around an `rjags` model. It requires a data input that includes columns that can be identified "Age" and "Length", the model needs to be specified (several options are available) and the priors must be specified. Priors include the max size with an error, length-at-birth with an error and upper limits for $k$ and $\sigma$. These latter two parameters have no informative priors and only require sensible upper bounds. Many fish species (including this example) have a size at birth of zero. Therefore, this can value can be used as a prior along with a very small error to indicate high certainty of this prior. The `L0.se` argument cannot be zero, but the model is specified to truncate $L_{0}$ at zero and keep growth positive.

Note that `rjags` (as well as several other packages that use the BUGS language) estimates parameter precision ($\tau$) rather than parameter standard error ($\theta{\sigma}$). Therefore, standard error is converted to precision as $\tau = (1/\theta{\sigma})^2$. This is handled by the `BayesGrowth` package so the user does not need to do this conversion themselves.

```{r model,message=FALSE, warning=FALSE}
library(BayesGrowth)
library(rjags)

data("example_data")
## Biological info - lengths in mm
max_size <- 440
max_size_se <- 5
birth_size <- 0
birth_size_se <- 0.001 #  cannot be zero

# Use the function to estimate the JAGS model
results <- Estimate_MCMC_Growth(example_data, Model = "VB" ,
                     iter = 100000, 
                     n.chains = 4,  # minimum of 3 chains recommended
                     BurnIn = 10000, # default is 1000
                     thin = 10,      # a thinning rate of 10 is applied to overcome autocorrelation
                     Linf = max_size,
                     Linf.se = max_size_se,
                     L0 = birth_size,
                     L0.se = birth_size_se,
                     sigma.max = 100,
                     k.max = 1)

```

## Outputs and compatibility with `rjags` and coda packages

The function returns the `rjags` outputs which is an object of class 'mcmc.list'
```{r head,message=FALSE}
head(results,3)

str(results)
```

## Summaries
Therefore, all of the diagnostics from the `rjags` library can be used. For example, a summary of results can be produced.
```{r summary,message=FALSE}
summary(results)
```

## Correlation matrix
The parameter correlation matrix can also be returned. This can be examined using the `crosscorr` function in the `coda` package which is loaded simulatenously with `rjags`.
```{r corrmat,message=FALSE}
library(rjags)

crosscorr(results)
```
## Chain convergence
The chains of the MCMC model can be examined using a trace plot. The left hand panels show the chains for each parameter as they progress through the MCMC iterations. The right hand panels show the posterior distributions of each parameter. As this model is specified to have a normal distribution, all parameter posteriors should be normally distributed once convergence has been reached. $L_{0}$ is an exception as this parameter is truncated to remain above zero. Therefore, as $L_{0}$ approaches zero it will be right skewed. This plot shows good model convergence. All of the chains overlap and each of the parameters has the correct posterior distribution with a single mode.
```{r Diagnostics,message=FALSE,  fig.height = 10, fig.width = 8}
plot(results,density = T, smooth = F)
```

Convergence can also be checked using a Gelman Rubin test. If all Point ests for each parameter are less than 1.2 then convergence has been reached. Ideally these should be close to one. If not, then the number of iterations should be increased. This can be examined using the `gelman.diag` function in the `coda` package
```{r GelmabRubin,message=FALSE}
gelman.diag(results)
```

## Autocorrelation
Autocorrelation can be examined using the `acfplot` function in the `coda` package (loaded automatically along with `rjags`). This plot shows the autocorrelation lag that occurs in the MCMC model for each parameter. If each parameter has an autocorrelation value of zero at the end of the lag series, then no autocorrelation has occured.
```{r Autocorr,message=FALSE}
acfplot(results)
```

## Other useful `BayesGrowth` functions
Additional `BayesGrowth` functions are available that help the user manipulate the returned `Estimate_MCMC_Growth` object. For example `Get_MCMC_parameters` will return a tibble of parameter results and statistics as a more management object than `summary()`.

```{r pars,message=FALSE}
Get_MCMC_parameters(results)
```

The `Calculate_MCMC_growth_curve` function will provide confidence intervals around the growth curve based on MCMC parameter percentiles. This is essentially a wrapper around the `tidybayes::mean_qi()` function which means it can be passed straight into a ggplot with the `tidybayes::geom_line_ribbon` function.

```{r plot,message=FALSE, fig.height = 6, fig.width = 8, warning=FALSE}

# Return a growth curve with 50th and 95th percentiles
growth_curve <- Calculate_MCMC_growth_curve(results, Model = "VB",
                                            max.age = max(example_data$Age), probs = c(.5,.95))
library(tidybayes)
library(ggplot2)

ggplot(growth_curve, aes(Age, LAA))+
  geom_point(data = example_data, aes(Age, Length), alpha = .3)+
  geom_lineribbon( size = .8) +
  labs(y = "Total Length (mm)", x = "Age (yrs)")+
  scale_fill_brewer(palette="BuPu", direction=-1)+
  scale_y_continuous(expand = c(0,0))+
  scale_x_continuous(expand = c(0,0), breaks = seq(0,13,1))+
  theme_bw()+
  theme(text = element_text(size = 14))

```

This represents a much improved fit over a standard non-linear estimated model, even if the length-at-birth were fixed at zero. Here the fit is compared using an nls model fit using the `AquaticLifeHistory` package (https://jonathansmart.github.io/AquaticLifeHistory/).

```{r compare_plot,message=FALSE, fig.height = 6, fig.width = 8, warning=FALSE, echo=FALSE}
 
library(AquaticLifeHistory)
fixed_mod <- Estimate_Growth(example_data,n.bootstraps = 1, Birth.Len = 0, models = "VB", plots = FALSE)
free_mod <- Estimate_Growth(example_data,n.bootstraps = 1, models = "VB", plots = FALSE)
growth_curve <- Calculate_MCMC_growth_curve(results, Model = "VB",
                                            max.age = max(example_data$Age), probs = c(.95))
ggplot(growth_curve, aes(Age, LAA))+
  geom_line(data = free_mod$Estimates,inherit.aes = FALSE,
            aes(Age, AVG, col = "nls model - free L0"), size = 1.5)+

  geom_line(data = fixed_mod$Estimates,inherit.aes = FALSE,
            aes(Age, AVG, col = "nls model - fixed L0"), size = 1.5)+
  geom_point(data = example_data, aes(Age, Length), alpha = .3)+
  geom_lineribbon( aes(fill = "MCMC model", col = "MCMC model"),size = 1.5, alpha = .5) +
   geom_line(aes(Age, LAA, col = "MCMC model"), size = 1.5)+
  labs(y = "Total Length (mm)", x = "Age (yrs)")+
  scale_color_viridis_d(name = "Model", begin = .3, end = .8)+
  scale_fill_viridis_d(begin = .5, end = .6)+
  guides(fill = FALSE)+
  scale_y_continuous(expand = c(0,0))+
  scale_x_continuous(expand = c(0,0), breaks = seq(0,13,1))+
  theme_bw()+
  theme(text = element_text(size = 14))

```

# DIC calculation

The Deviance Information Criterion (DIC) should be calculated for different candidate models to determine the best fitting growth model. The `Calculate_DIC` function will calculate this for all three models in a single function call. The user should specify the same arguments as the original `Estimate_MCMC_Growth` function call to ensure consistentcy. If the arguments of `Estimate_MCMC_Growth` are updated then `Calculate_DIC` should be re run accordingly

```{r DIC,message=FALSE}
Calculate_DIC(data = example_data,
                     iter = 10000,
                     Linf = max_size,
                     Linf.se = max_size_se,
                     L0 = birth_size,
                     L0.se = birth_size_se,
                     sigma.max = 100,
                     k.max = 1)

```

The lowest penalised deviance value denotes the best fitting model given these priors and model specifications. The penalised deviance is the sum of the Mean deviance ($\overline{D(\theta)}$) and the penalised deviance ($pD$). The returned dataframe will be ordered with models in descending order of fit.

